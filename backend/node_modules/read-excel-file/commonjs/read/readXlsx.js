"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = readXlsx;
exports.dropEmptyRows = dropEmptyRows;
exports.dropEmptyColumns = dropEmptyColumns;

var _parseDate = _interopRequireDefault(require("./parseDate"));

var _xlsx = require("../xml/xlsx");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Maps "A1"-like coordinates to `{ row, column }` numeric coordinates.
var letters = ["", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]; // https://hexdocs.pm/xlsxir/number_styles.html

var BUILT_IN_DATE_NUMBER_FORMAT_IDS = [14, 15, 16, 17, 18, 19, 20, 21, 22, 27, 30, 36, 45, 46, 47, 50, 57]; // "The minimum viable XLSX reader"
// https://www.brendanlong.com/the-minimum-viable-xlsx-reader.html

/**
 * Reads an (unzipped) XLSX file structure into a 2D array of cells.
 * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).
 * @param  {number?} options.sheet - Workbook sheet id (`1` by default).
 * @param  {string?} options.dateFormat - Date format, e.g. "mm/dd/yyyy". Values having this format template set will be parsed as dates.
 * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).
 * @return {object} An object of shape `{ data, cells, properties }`. `data: string[][]` is an array of rows, each row being an array of cell values. `cells: string[][]` is an array of rows, each row being an array of cells. `properties: object` is the spreadsheet properties (e.g. whether date epoch is 1904 instead of 1900).
 */

function readXlsx(contents, xml) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!options.sheet) {
    options = _objectSpread({
      sheet: 1
    }, options);
  } // Some Excel editors don't want to use standard naming scheme for sheet files.
  // https://github.com/tidyverse/readxl/issues/104


  var filePaths = parseFilePaths(contents['xl/_rels/workbook.xml.rels'], xml); // Default file path for "shared strings": "xl/sharedStrings.xml".

  var values = filePaths.sharedStrings ? parseValues(contents[filePaths.sharedStrings], xml) : []; // Default file path for "styles": "xl/styles.xml".

  var styles = filePaths.styles ? parseStyles(contents[filePaths.styles], xml) : {};
  var properties = parseProperties(contents['xl/workbook.xml'], xml); // A feature for getting the list of sheets in an Excel file.
  // https://github.com/catamphetamine/read-excel-file/issues/14

  if (options.getSheets) {
    return properties.sheets.map(function (_ref) {
      var name = _ref.name;
      return {
        name: name
      };
    });
  } // Find the sheet by name, or take the first one.


  var sheetRelationId;

  if (typeof options.sheet === 'number') {
    var _sheet = properties.sheets[options.sheet - 1];
    sheetRelationId = _sheet && _sheet.relationId;
  } else {
    for (var _iterator = _createForOfIteratorHelperLoose(properties.sheets), _step; !(_step = _iterator()).done;) {
      var _sheet2 = _step.value;

      if (_sheet2.name === options.sheet) {
        sheetRelationId = _sheet2.relationId;
        break;
      }
    }
  } // If the sheet wasn't found then throw an error.
  // Example: "xl/worksheets/sheet1.xml".


  if (!sheetRelationId || !filePaths.sheets[sheetRelationId]) {
    throw createSheetNotFoundError(options.sheet, properties.sheets);
  } // Parse sheet data.


  var sheet = parseSheet(contents[filePaths.sheets[sheetRelationId]], xml, values, styles, properties, options); // If the sheet is empty.

  if (sheet.cells.length === 0) {
    if (options.properties) {
      return {
        data: [],
        properties: properties
      };
    }

    return [];
  }

  var _sheet$dimensions = _slicedToArray(sheet.dimensions, 2),
      leftTop = _sheet$dimensions[0],
      rightBottom = _sheet$dimensions[1];

  var colsCount = rightBottom.column - leftTop.column + 1;
  var rowsCount = rightBottom.row - leftTop.row + 1; // `sheet.cells` seem to not necessarily be sorted by row and column.

  var data = new Array(rowsCount);
  var i = 0;

  while (i < rowsCount) {
    data[i] = new Array(colsCount);
    var j = 0;

    while (j < colsCount) {
      data[i][j] = null;
      j++;
    }

    i++;
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose(sheet.cells), _step2; !(_step2 = _iterator2()).done;) {
    var cell = _step2.value;
    var row = cell.row - leftTop.row;
    var column = cell.column - leftTop.column;
    data[row][column] = cell.value;
  } // Fill in the row map.


  var _options = options,
      rowMap = _options.rowMap;

  if (rowMap) {
    var _i2 = 0;

    while (_i2 < data.length) {
      rowMap[_i2] = _i2;
      _i2++;
    }
  }

  data = dropEmptyRows(dropEmptyColumns(data, {
    onlyTrimAtTheEnd: true
  }), {
    onlyTrimAtTheEnd: true,
    rowMap: rowMap
  });

  if (options.transformData) {
    data = options.transformData(data); // data = options.transformData(data, {
    //   dropEmptyRowsAndColumns(data) {
    //     return dropEmptyRows(dropEmptyColumns(data), { rowMap })
    //   }
    // })
  }

  if (options.properties) {
    return {
      data: data,
      properties: properties
    };
  }

  return data;
}

function calculateDimensions(cells) {
  var comparator = function comparator(a, b) {
    return a - b;
  };

  var allRows = cells.map(function (cell) {
    return cell.row;
  }).sort(comparator);
  var allCols = cells.map(function (cell) {
    return cell.column;
  }).sort(comparator);
  var minRow = allRows[0];
  var maxRow = allRows[allRows.length - 1];
  var minCol = allCols[0];
  var maxCol = allCols[allCols.length - 1];
  return [{
    row: minRow,
    column: minCol
  }, {
    row: maxRow,
    column: maxCol
  }];
}

function colToInt(col) {
  // `for ... of ...` would require Babel polyfill for iterating a string.
  var n = 0;
  var i = 0;

  while (i < col.length) {
    n *= 26;
    n += letters.indexOf(col[i]);
    i++;
  }

  return n;
}

function CellCoords(coords) {
  // Examples: "AA2091", "R988", "B1"
  coords = coords.split(/(\d+)/);
  return [// Row.
  parseInt(coords[1]), // Column.
  colToInt(coords[0].trim())];
} // Example of a `<c/>`ell element:
//
// <c>
//    <f>string</f> — formula.
//    <v>string</v> — formula pre-computed value.
//    <is>
//       <t>string</t> — an `inlineStr` string (rather than a "common string" from a dictionary).
//       <r>
//          <rPr>
//            ...
//          </rPr>
//          <t>string</t>
//       </r>
//       <rPh sb="1" eb="1">
//          <t>string</t>
//       </rPh>
//       <phoneticPr fontId="1"/>
//    </is>
//    <extLst>
//       <ext>
//          <!--any element-->
//       </ext>
//    </extLst>
// </c>
//


function Cell(cellNode, sheet, xml, values, styles, properties, options) {
  var coords = CellCoords(cellNode.getAttribute('r'));
  var valueElement = (0, _xlsx.getCellValue)(sheet, cellNode); // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.
  // So using `value && ...` instead of `if (value !== undefined) { ... }` here
  // for uniform compatibility with both `xpath` and native `DOMParser`.

  var value = valueElement && valueElement.textContent;
  var type;

  if (cellNode.hasAttribute('t')) {
    type = cellNode.getAttribute('t');
  } else {
    // Default cell type is "n" (numeric).
    // http://www.datypic.com/sc/ooxml/t-ssml_CT_Cell.html
    type = 'n';
  } // Available Excel cell types:
  // https://github.com/SheetJS/sheetjs/blob/19620da30be2a7d7b9801938a0b9b1fd3c4c4b00/docbits/52_datatype.md
  //
  // Some other document (seems to be old):
  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/ST_CellType.html
  //


  switch (type) {
    // If the cell contains formula string.
    case 'str':
      value = value.trim();

      if (value === '') {
        value = undefined;
      }

      break;
    // If the cell contains an "inline" (not "shared") string.

    case 'inlineStr':
      value = (0, _xlsx.getCellInlineStringValue)(cellNode);

      if (value === undefined) {
        throw new Error("Unsupported \"inline string\" cell value structure: ".concat(cellNode.textContent));
      }

      value = value.trim();

      if (value === '') {
        value = undefined;
      }

      break;
    // If the cell contains a "shared" string.
    // "Shared" strings is a way for an Excel editor to reduce
    // the file size by storing "commonly used" strings in a dictionary
    // and then referring to such strings by their index in that dictionary.

    case 's':
      // If a cell has no value then there's no `<c/>` element for it.
      // If a `<c/>` element exists then it's not empty.
      // The `<v/>`alue is a key in the "shared strings" dictionary of the
      // XLSX file, so look it up in the `values` dictionary by the numeric key.
      value = values[parseInt(value)];
      value = value.trim();

      if (value === '') {
        value = undefined;
      }

      break;

    case 'b':
      value = value === '1' ? true : false;
      break;
    // Stub: blank stub cell that is ignored by data processing utilities.

    case 'z':
      value = undefined;
      break;
    // Error: `value` is a numeric code.
    // They also wrote: "and `w` property stores its common name".
    // It's unclear what they meant by that.

    case 'e':
      value = decodeError(value);
      break;
    // Date: a string to be parsed as a date.
    // (usually a string in "ISO 8601" format)

    case 'd':
      if (value === undefined) {
        break;
      }

      value = new Date(value);
      break;

    case 'n':
      if (value === undefined) {
        break;
      }

      value = parseFloat(value); // XLSX does have "d" type for dates, but it's not commonly used.
      //  specific format for dates.
      // Sometimes a date can be heuristically detected.
      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777
      //
      // Format IDs:
      // https://xlsxwriter.readthedocs.io/format.html#format-set-num-format
      //

      if (cellNode.hasAttribute('s')) {
        var styleId = parseInt(cellNode.getAttribute('s'));
        var style = styles[styleId];

        if (!style) {
          throw new Error("Cell style not found: ".concat(styleId));
        }

        if (BUILT_IN_DATE_NUMBER_FORMAT_IDS.indexOf(parseInt(style.numberFormat.id)) >= 0 || options.dateFormat && style.numberFormat.template === options.dateFormat || options.smartDateParser !== false && style.numberFormat.template && isDateTemplate(style.numberFormat.template)) {
          value = (0, _parseDate["default"])(value, properties);
        }
      }

      break;

    default:
      throw new TypeError("Cell type not supported: ".concat(type));
  } // Convert empty values to `null`.


  if (value === undefined) {
    value = null;
  }

  return {
    row: coords[0],
    column: coords[1],
    value: value
  };
}

function dropEmptyRows(data) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      rowMap = _ref2.rowMap,
      _ref2$accessor = _ref2.accessor,
      accessor = _ref2$accessor === void 0 ? function (_) {
    return _;
  } : _ref2$accessor,
      onlyTrimAtTheEnd = _ref2.onlyTrimAtTheEnd;

  // Drop empty rows.
  var i = data.length - 1;

  while (i >= 0) {
    // Check if the row is empty.
    var empty = true;

    for (var _iterator3 = _createForOfIteratorHelperLoose(data[i]), _step3; !(_step3 = _iterator3()).done;) {
      var cell = _step3.value;

      if (accessor(cell) !== null) {
        empty = false;
        break;
      }
    } // Remove the empty row.


    if (empty) {
      data.splice(i, 1);

      if (rowMap) {
        rowMap.splice(i, 1);
      }
    } else if (onlyTrimAtTheEnd) {
      break;
    }

    i--;
  }

  return data;
}

function dropEmptyColumns(data) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$accessor = _ref3.accessor,
      accessor = _ref3$accessor === void 0 ? function (_) {
    return _;
  } : _ref3$accessor,
      onlyTrimAtTheEnd = _ref3.onlyTrimAtTheEnd;

  var i = data[0].length - 1;

  while (i >= 0) {
    var empty = true;

    for (var _iterator4 = _createForOfIteratorHelperLoose(data), _step4; !(_step4 = _iterator4()).done;) {
      var row = _step4.value;

      if (accessor(row[i]) !== null) {
        empty = false;
        break;
      }
    }

    if (empty) {
      var j = 0;

      while (j < data.length) {
        data[j].splice(i, 1);
        j++;
      }
    } else if (onlyTrimAtTheEnd) {
      break;
    }

    i--;
  }

  return data;
}

function parseSheet(content, xml, values, styles, properties, options) {
  var sheet = xml.createDocument(content);
  var cells = (0, _xlsx.getCells)(sheet);

  if (cells.length === 0) {
    return {
      cells: []
    };
  }

  cells = cells.map(function (node) {
    return Cell(node, sheet, xml, values, styles, properties, options);
  });
  var dimensions = (0, _xlsx.getDimensions)(sheet);

  if (dimensions) {
    dimensions = dimensions.split(':').map(CellCoords).map(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          row = _ref5[0],
          column = _ref5[1];

      return {
        row: row,
        column: column
      };
    }); // When there's only a single cell on a sheet
    // there can sometimes be just "A1" for the dimensions string.

    if (dimensions.length === 1) {
      dimensions = [dimensions[0], dimensions[0]];
    }
  } else {
    dimensions = calculateDimensions(cells);
  }

  return {
    cells: cells,
    dimensions: dimensions
  };
}

function parseValues(content, xml) {
  if (!content) {
    return [];
  }

  return (0, _xlsx.getSharedStrings)(xml.createDocument(content));
} // http://officeopenxml.com/SSstyles.php
// Returns an array of cell styles.
// A cell style index is its ID.


function parseStyles(content, xml) {
  if (!content) {
    return {};
  } // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/708978af-b598-45c4-a598-d3518a5a09f0/howwhen-is-cellstylexfs-vs-cellxfs-applied-to-a-cell?forum=os_binaryfile
  // https://www.office-forums.com/threads/cellxfs-cellstylexfs.2163519/


  var doc = xml.createDocument(content);
  var baseStyles = (0, _xlsx.getBaseStyles)(doc).map(parseCellStyle);
  var numberFormats = (0, _xlsx.getNumberFormats)(doc).map(parseNumberFormatStyle).reduce(function (formats, format) {
    // Format ID is a numeric index.
    // There're some standard "built-in" formats (in Excel) up to about `100`.
    formats[format.id] = format;
    return formats;
  }, []);

  var getCellStyle = function getCellStyle(xf) {
    if (xf.hasAttribute('xfId')) {
      return _objectSpread(_objectSpread({}, baseStyles[xf.xfId]), parseCellStyle(xf, numberFormats));
    }

    return parseCellStyle(xf, numberFormats);
  };

  return (0, _xlsx.getCellStyles)(doc).map(getCellStyle);
}

function parseNumberFormatStyle(numFmt) {
  return {
    id: numFmt.getAttribute('numFmtId'),
    template: numFmt.getAttribute('formatCode')
  };
} // http://www.datypic.com/sc/ooxml/e-ssml_xf-2.html


function parseCellStyle(xf, numFmts) {
  var style = {};

  if (xf.hasAttribute('numFmtId')) {
    var numberFormatId = xf.getAttribute('numFmtId'); // Built-in number formats don't have a `<numFmt/>` element in `styles.xml`.
    // https://hexdocs.pm/xlsxir/number_styles.html

    if (numFmts[numberFormatId]) {
      style.numberFormat = numFmts[numberFormatId];
    } else {
      style.numberFormat = {
        id: numberFormatId
      };
    }
  }

  return style;
} // I guess `xl/workbook.xml` file should always be present inside the *.xlsx archive.


function parseProperties(content, xml) {
  var book = xml.createDocument(content);
  var properties = {}; // Read `<workbookPr/>` element to detect whether dates are 1900-based or 1904-based.
  // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel
  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/workbookPr.html

  var workbookProperties = (0, _xlsx.getWorkbookProperties)(book);

  if (workbookProperties && workbookProperties.getAttribute('date1904') === '1') {
    properties.epoch1904 = true;
  } // Get sheets info (indexes, names, if they're available).
  // Example:
  // <sheets>
  //   <sheet
  //     xmlns:ns="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
  //     name="Sheet1"
  //     sheetId="1"
  //     ns:id="rId3"/>
  // </sheets>
  // http://www.datypic.com/sc/ooxml/e-ssml_sheet-1.html


  properties.sheets = [];

  var addSheetInfo = function addSheetInfo(sheet) {
    if (sheet.getAttribute('name')) {
      properties.sheets.push({
        id: sheet.getAttribute('sheetId'),
        name: sheet.getAttribute('name'),
        relationId: sheet.getAttribute('r:id')
      });
    }
  };

  (0, _xlsx.getSheets)(book).forEach(addSheetInfo);
  return properties;
}
/**
 * Returns sheet file paths.
 * Seems that the correct place to look for the `sheetId` -> `filename` mapping
 * is `xl/_rels/workbook.xml.rels` file.
 * https://github.com/tidyverse/readxl/issues/104
 * @param  {string} content — `xl/_rels/workbook.xml.rels` file contents.
 * @param  {object} xml
 * @return {object}
 */


function parseFilePaths(content, xml) {
  // Example:
  // <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  //   ...
  //   <Relationship
  //     Id="rId3"
  //     Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"
  //     Target="worksheets/sheet1.xml"/>
  // </Relationships>
  var document = xml.createDocument(content);
  var filePaths = {
    sheets: {},
    sharedStrings: undefined,
    styles: undefined
  };

  var addFilePathInfo = function addFilePathInfo(relationship) {
    var filePath = relationship.getAttribute('Target');
    var fileType = relationship.getAttribute('Type');

    switch (fileType) {
      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles':
        filePaths.styles = getFilePath(filePath);
        break;

      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings':
        filePaths.sharedStrings = getFilePath(filePath);
        break;

      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet':
        filePaths.sheets[relationship.getAttribute('Id')] = getFilePath(filePath);
        break;
    }
  };

  (0, _xlsx.getRelationships)(document).forEach(addFilePathInfo); // Seems like "sharedStrings.xml" is not required to exist.
  // For example, when the spreadsheet doesn't contain any strings.
  // https://github.com/catamphetamine/read-excel-file/issues/85
  // if (!filePaths.sharedStrings) {
  //   throw new Error('"sharedStrings.xml" file not found in the *.xlsx file')
  // }

  return filePaths;
}

function getFilePath(path) {
  // Normally, `path` is a relative path inside the ZIP archive,
  // like "worksheets/sheet1.xml", or "sharedStrings.xml", or "styles.xml".
  // There has been one weird case when file path was an absolute path,
  // like "/xl/worksheets/sheet1.xml" (specifically for sheets):
  // https://github.com/catamphetamine/read-excel-file/pull/95
  // Other libraries (like `xlsx`) and software (like Google Docs)
  // seem to support such absolute file paths, so this library does too.
  if (path[0] === '/') {
    return path.slice('/'.length);
  } // // Seems like a path could also be a URL.
  // // http://officeopenxml.com/anatomyofOOXML-xlsx.php
  // if (/^[a-z]+\:\/\//.test(path)) {
  //   return path
  // }


  return 'xl/' + path;
}

function isDateTemplate(template) {
  var tokens = template.split(/\W+/);

  for (var _iterator5 = _createForOfIteratorHelperLoose(tokens), _step5; !(_step5 = _iterator5()).done;) {
    var token = _step5.value;

    if (['MM', 'DD', 'YY', 'YYYY'].indexOf(token) < 0) {
      return false;
    }
  }

  return true;
}

function createSheetNotFoundError(sheet, sheets) {
  var sheetsList = sheets && sheets.map(function (sheet, i) {
    return "\"".concat(sheet.name, "\" (#").concat(i + 1, ")");
  }).join(', ');
  return new Error("Sheet ".concat(typeof sheet === 'number' ? '#' + sheet : '"' + sheet + '"', " not found in the *.xlsx file.").concat(sheets ? ' Available sheets: ' + sheetsList + '.' : ''));
} // Decodes numeric error code to a string code.
// https://github.com/SheetJS/sheetjs/blob/19620da30be2a7d7b9801938a0b9b1fd3c4c4b00/docbits/52_datatype.md


function decodeError(errorCode) {
  // While the error values are determined by the application,
  // the following are some example error values that could be used:
  switch (errorCode) {
    case 0x00:
      return '#NULL!';

    case 0x07:
      return '#DIV/0!';

    case 0x0F:
      return '#VALUE!';

    case 0x17:
      return '#REF!';

    case 0x1D:
      return '#NAME?';

    case 0x24:
      return '#NUM!';

    case 0x2A:
      return '#N/A';

    case 0x2B:
      return '#GETTING_DATA';

    default:
      // Such error code doesn't exist. I made it up.
      return "#ERROR_".concat(errorCode);
  }
}
//# sourceMappingURL=readXlsx.js.map