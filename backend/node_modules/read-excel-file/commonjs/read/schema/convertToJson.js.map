{"version":3,"sources":["../../../source/read/schema/convertToJson.js"],"names":["DEFAULT_OPTIONS","isColumnOriented","data","schema","options","rowMap","validateSchema","transpose","columns","results","errors","i","length","result","read","push","error","row","rows","rowIndex","object","key","schemaEntry","isNestedSchema","type","Array","isArray","rawValue","indexOf","undefined","value","notEmpty","array","parseArray","map","_value","parseValue","required","column","prop","Object","keys","parse","parseCustomValue","parseValueOfType","oneOf","validate","message","String","isFinite","Number","Integer","stringifiedValue","parseFloat","URL","Email","Date","parseInt","date","properties","Boolean","Error","name","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_","entry"],"mappings":"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","sourcesContent":["import parseDate from '../parseDate'\r\n\r\nimport Integer, { isInteger } from '../../types/Integer'\r\nimport URL, { isURL } from '../../types/URL'\r\nimport Email, { isEmail } from '../../types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors, options)\r\n    if (result) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // The `1` compensates for the header row.\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(\r\n      value,\r\n      // Supports parsing array types.\r\n      // See `parseArray()` function for more details.\r\n      // Example `type`: String[]\r\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\r\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\r\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\r\n      options\r\n    )\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    value = parse(value)\r\n    if (value === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      if (typeof value === 'string') {\r\n        return { value }\r\n      }\r\n      // The global `isFinite()` function filters out:\r\n      // * NaN\r\n      // * -Infinity\r\n      // * Infinity\r\n      // All other values pass (including non-numbers).\r\n      if (typeof value === 'number') {\r\n        if (isFinite(value)) {\r\n          return { value: String(value) }\r\n        }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Number:\r\n    case Integer:\r\n      // Convert strings to numbers.\r\n      // Just an additional feature.\r\n      // Won't happen when called from `readXlsx()`.\r\n      if (typeof value === 'string') {\r\n        const stringifiedValue = value\r\n        value = parseFloat(value)\r\n        if (String(value) !== stringifiedValue) {\r\n          return { error: 'invalid' }\r\n        }\r\n      } else if (typeof value !== 'number') {\r\n        return { error: 'invalid' }\r\n      }\r\n      // The global `isFinite()` function filters out:\r\n      // * NaN\r\n      // * -Infinity\r\n      // * Infinity\r\n      // All other values pass (including non-numbers).\r\n      // At this point, `value` can only be a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case URL:\r\n      if (typeof value === 'string') {\r\n        if (isURL(value)) {\r\n          return { value }\r\n        }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Email:\r\n      if (typeof value === 'string') {\r\n        if (isEmail(value)) {\r\n          return { value }\r\n        }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid' }\r\n        }\r\n        value = parseInt(value)\r\n        const date = parseDate(value, options.properties)\r\n        if (!date) {\r\n          return { error: 'invalid' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"],"file":"convertToJson.js"}